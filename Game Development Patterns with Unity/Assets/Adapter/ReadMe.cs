using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/*어뎁터 패턴 
 * 
 *  어뎁터 패턴은 호환되지 않는 두 개의 인터페이스를 조정한다. 플래그 어댑터와 마찬가지로 조정 대상을 
 *  수정하지 않고 한 인터페이스를 다른 인터페이스와 연결한다. 취약한 부분이 있어 리팩터링할 수 없는 
 *  레거시 코드를 다루어야 할 때나 업그레이드했을 때의 이슈를 피하기 위해 수정하기 싫지만 서드파티 
 *  라이브러리에 기능을 추가해야 할 때 유용하다.
 *  
 *  주요 접근 방식 
 *  
 *  - 객체 어댑터 : 객체 어댑터(Object Adapter) 버전에서 패턴은 객체 구성을 사용하고 어댑터는 조정한 객체의
 *  래퍼(Wrapper)처럼 행동한다. 필요한 메서드가 없는 클래스가 있다면 도움이 되지만 직접 수정하지는 못한다. 
 *  객체 어댑터는 원래 클래스의 메서드를 선택하고 우리가 필요한 것으로 조정한다. 
 *  
 *  - 클래스 어댑터 : 클래스 어댑터(Class Adapter) 버전에서 어댑터는 기존 클래스의 인터페이스를 다른 클래스의 
 *  인터페이스에 적용하기 위해 상속을 사용한다. 다른 클래스와 같이 작동해야 하지만 직접 수정할 수 없는 클래스를 
 *  조정해야 할 때 유용하다.
 *  
 *  객체 어댑터와 클래스 어댑터 모두 어댑터 클래스는 클라이언트와 어댑트된 엔티티(어댑티(Adaptee))사이에 위치한다.
 *  그러나 클래스 어댑터는 상속을 통해 어댑티와의 관계를 설정한다. 객체 어댑터는 적용을 위해 어댑티의 인스턴스를 
 *  래핑하려고 컴포지션(Composition)을 사용한다.
 *  
 *  두 경우 모두 우리가 적용하는 엔티티는 수정되지 않는다. 클라이언트는 저정하고자 하는 것이 무엇인지 알지 못한다.
 *  적용된 객체와 통신하기 위한 일관된 인터페이스가 있다는 것만 안다.
 *  
 *  컴포지션 및 상속은 객체 간 관계를 정의하는 방법이다. 서로 어떻게 연관이 있는지 설명한다. 그리고 객체와 클래스 
 *  어댑터 간 차이가 부분적으로 두 어댑터의 차이를 결정한다.
 *  
 *  주의해야 할 점은 퍼사드 패턴(Facade Pattern)과 어댑터가 종종 헷갈릴 수 있다는 점이다. 주요 차이점은 퍼사드 패턴은
 *  단순화된 전면 인터페이스를 복잡한 시스템으로 설정한다는 점이다. 어댑터 패턴은 클라이언트에 일관적인 인터페이스를 
 *  유지하면서 인터페이스를 유지하면서 호환되지 않는 시스템을 조정한다. 어댑터 패턴과 퍼사드 패턴 모두 구조적 패턴
 *  모두 구조적 패턴이지만 완전히 다른 목적을 가지고 있어 관련이 있다.
 *  
 *  장점
 *  - 수정 없이 조정 가능 : 오래된 코드나 서드파티 코드를 수정 없이 조정하는 표준 접근 방식을 제공한다.
 *  - 재사용성 및 유연서 : 새로운 시스템에서 최소한의 변경만으로 레거시 코드를 계속 사용할 수 있다. 개발 비용을 정약할 수 
 *  
 *  단점
 * - 지속적인 레거시 사용 : 새 시스템에서 레거시 코드를 사용하는 것은 비용 면에서는 효율적이지만 장기적으로 보면 문제가 된다. 
 *                                  오래된 코드는 더 이상 사용되지 않으며 새로운 유니티 버전 혹은 서드파티 라이브러리에서 호환되지 않아
 *                                  업그레이드 옵션이 제한될 수 있다.
 *  - 약간의 성능 저하 : 경우에 따라 객체 간 호출을 리다이렉션하여 약간의 성능 저하가 발생할 수 있다. 다만 이슈가 되기에는 아주 작은 성능 저하다.
 *                               
 * 어댑터 패턴을 사용하는 경우
 * 유니티에서 어댑터를 사용하는 경우에는 유니티의 에셋 스토어에서 다운로드한 서드파티 라이브러리가 있고 새로운 기능 추가를 위해 핵심 
 * 클래스 및 인터페이스의 일부를 수정해야 할 때다. 그러나 서드파티 코드를 변경하면 라이브러리 소유자에서 업데이트된 사항을 가져올 때마다
 * 병합에 문제가 발생할 수 있다. 
 * 
 * 서드파티 라이브러리 소유자가 필요한 변경 사항을 통합하거나 코드를 수정하고 누락된 기능을 추가할 때까지 기다려야 한다. 두 선택 모두 
 * 나름의 위험과 보상이 있다. 그러나 어댑터 패턴은 기존의 클래스 사이에 어댑터를 배치하여 직접 수정하지 않고도 함께 작동할 수 있도록 해 
 * 이런 딜레마를 해결한다. 
 * 
 * 
 * 
 * 
 * 
 */
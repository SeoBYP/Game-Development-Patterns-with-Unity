using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/*데커에이터 패턴
 * 
 * 데커레이터는 기존 객체를 변경하지 않고 새로운 기능을 추가할 수 있는 패턴이다
 * 원래 클래스를 래핑하는 데커레이터 클래스를 생성하여 가능한 것이다.
 * 이 메커니즘을 사용하면 객체에 새로운 행동을 쉽게 부여하거나 분리할 수 있다.
 * 
 * IWeapon 인터페이스는 데커레이팅된 객체와 해당 데커레이터 간의 일관된 메서드 서명을 유지하는 구현 
 * 계약을 설정한다. WeaponDecorator는 대상 객체를 래핑하고 구체적인 데커레이터 클래스는 동작을 향상시키거나
 * 오버라이팅한다.
 * 
 * 메서드 서명과 데커레이팅된 객체의 전체 구조는 프로세스 중에는 수정되지 않고 행동이나 속성 값만 수정된다. 
 * 객체에서 쉽게 데커레이션을 없애고 원래 형태로 되돌릴 수 있다.
 * 
 * MonoBehaviour와 ScriptableObject 같은 유니티의 기본 API 클래스는 오브젝트의 인스턴스를 초기화하는 데
 * 생성자를 사용하지 않는다. 대신 MonoBehaviour는 게임 오브젝트와 연결된 클래스를 초기화한다. 모든 초기화 코드는
 * Awake() 혹은 Start() 콜백에 구현된다. 데커레이터 패턴의 장점을 잃지 않으면서 유니티 API의 핵심 기능을 사용할 
 * 수 있도록 데커레이터 패턴을 조정하는 방법을 찾아야 한다.
 * 
 * 장점
 *  - 서브클래싱의 대안 : 상속은 정적인 프로세스다. 데커레이터 패턴과 달리 런타임에 존재하는 객체의 행동이 
 *                               확장되는 것을 허용하지 않는다. 원하는 동작이 있는 같은 부모 클래스의 인스턴스만 다른 인스턴스로 
 *                               교체할 수 있다. 데커레이터 패턴은 서브클래싱의 동적인 대안이며 상속의 한계 또한 극복한다.
 *  - 런타임 다이내믹 : 데커레이터 패턴은 객체에 데커레이터를 추가하여 런타임에 기능을 추가할 수 있다.
 *                             또한 데커레이터를 제거하여 객체를 원래 형태로 되돌릴 수 있다.
 *  단점
 *  - 복잡한 관계 : 객체 주변에 다양한 계층의 데커레이터가 있다면 초기화 체인과 데커레이터 간의 관계를 추적하는 것이 매우 복잡해질 수 있다.
 *  - 복잡해지는 코드 : 데커레이터 패턴을 구현하는 방법에 따라 몇 개의 작은 데커레이터 클래스를 유지 및 관리해야 할 수도 있어 
 *                             코드가 복잡해질 수 있다. 실제로 단점으로 작용하는 시기와 이유는 상황에 따라 다르며 일정하지 않다. 이후 
 *                             살펴볼 코드에서는 각 데커레이터가 설정 가능한 에셋으로 저장하는 ScroptableObject 인스턴스이기에 문제가 되지 않는다.
 *                             
 * 데커레이터 패턴을 사용하는 경우
 *  부착물이 있는 무기 시스템을 구현한다. 
 *   - 무기에 다양한 부착물을 부착할 수 있어야 한다.
 *   - 런타임에 추가하고 삭제하는 것이 가능해야 한다.
 *   데커레이터 패턴은 핵심 요구사항을 충족하는 방법을 제공한다. 개별 객체에 행동을 추가 및 삭제하는 기능의 시스템을 
 *   구현할 때 고려해야 하는 패턴이다. 예를 들어 수집형 카드 게임(CCG)에서는 플레이어가 서로 겹쳐진 아티팩트 카드로
 *   기본 카드의 능력을 올릴 수 있는 메커니즘을 구현한다. 혹은 플레이어가 특정 능력치를 버프하고자 액세서리로
 *   갑옷을 꾸밀 수 있는 옷장 시스템을 구현한다. 두 경우 모두 데커레이션 패턴을 사용하면 메커니즘 및 시스템을 구현하는 데 
 *   좋은 시작점이 될 것이다.
 */
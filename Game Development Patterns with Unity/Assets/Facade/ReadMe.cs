using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/*퍼사드 패턴 
 * 
 * 퍼사드 패턴은 이름에서 유추해볼 수 있듯이 시스템의 복잡한 내부 작업을 추상화하는 단순화된 전면
 * 인터페이스를 제공한다. 게임은 다양한 시스템의 상호작용으로 복잡하게 구선되어 있어 게임 개발에 유리한 패턴이다. 
 * 오토바이 엔진의 핵심 컴포넌트 동작 및 상호작용을 시뮬레이션하는 코드를 작성한 후 전체 시스템과 상호작용하기 위한 
 * 간단한 인터페이스를 살펴보겠다. 
 * 
 * 퍼사드 패턴의 이름은 건물의 퍼사드와 유사하다. 복잡한 내부 구조를 숨기는 외부 면이다. 아키텍처 구축과 달리 소프트웨어
 * 개발에서 퍼사드의 목표는 미화가 아니다. 단순화다. 퍼사드 패턴의 구현은 보통 상호작용하는 서브시스템 모음에 단순화된 
 * 인터페이스로 작용하는 단일 클래스로 제한된다. 
 * Enginefacade의 StartEngine()을 호출할 때 씬 뒤에서 일어나는 일과 엔진을 구성하는 요소 및 도달 방법을 알지 못한다. 
 * 내부에서 무엇이 일어나는지 볼 수도 없고 알 필요도 없다. 유일한 관심사는 엔진의 시동이 걸린다는 사실이다. 퍼사드 패턴은
 * 코드에서 이와 동일한 수준의 추상화를 제공하고 시스템의 세부 사항은 내부에 보관한다.
 * 
 * 장점 
 * - 복잡한 코드 본문에 단순화된 인터페이스 제공 : 견고한 퍼사드 클래스는 복잡한 시스템과 상호작용할 수 있는 단순화된 
 * 인터페이스를 제공하면서 클라이언트에게 복잡성을 숨긴다.
 * - 쉬운 리팩터링 : 퍼사드 패턴 뒤에 고립된 코드를 리팩터링하는 것은 훨씬 쉽다. 시스템 뒤에서 구성 요소가 수정되는 동안
 * 시스템의 인터페이스는 클라이언트와의 일관성을 유지하는 때문이다.
 * 
 * 단점
 * - 지저분한 코드를 쉬게 숨길 수 있다 : 깨긋한 전면 인터페이스에 지저분한 코드를 숨기기 위해 퍼사드 패턴을 사용하면
 * 장기적으로 봤을 때 패턴의 핵심 이점을 없애게 된다. 퍼사드 패턴은 리팩터링하는 시간까지 몇몇 코드를 숨기는 방법을 
 * 제공한다. 그러나 제대로 리팩터링할 충분한 시간이 거의 없어 이후 충분히 시간을 들여 수정하기 힘들다.
 * - 너무 많은 퍼사드 : 핵심 시스템의 퍼사드 패턴처럼 행동하는 전역적 접근이 가능한 매니저 클래스는 유니티 개발자 사이에서
 * 인기가 많다. 종종 싱글턴 패턴과 퍼사드 패턴을 결합하여 구현한다. 하지만 안타깝게도 이 조합은 남용되기 쉬우며 너무 많은 
 * 매니저 클래스가 각 함수에 의존하는 코드베이스로 끝나고 만다. 결과적으로 디버깅, 리팩터링, 단위 테스트 구성 요소는 매우 어려워진다.
 * 
 * 추상 팩토리 패턴 : 클라이언트 코드에서 서브시스템 객체가 초기화되는 방식만을 숨기려면 퍼사드 패턴 대신 추강 팩토리 패턴을 고려한다.
 * 어댑터 패턴 : 호환되지 않는 두 인터페이스를 연결하고자 기존 클래스에 래퍼를 작성하려는 경우 어댑터 패턴을 고려한다.
 */
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/*방문자 패턴
 * 
 *방문자 패턴의 주요 목적은 간단하다. 객체에 방문자는 구조체의 특정 요소를 작업할 수 있다.
 *이 과정을 통해 객체는 직접 수정하지 않아도 방문자에게서 새로운 기능을 얻는다. 이해하기
 *어려울 수 있지만 객체를 폐쇠된 데이터 및 논리 컨테이너 대신 구조체로 상상한다면 쉽게 
 *시각화할 수 있을 것이다. 즉 방문자 패턴으로 객체의 구조를 탐색하고 객체의 요소에 작동하며
 *수정하지 않고 기능을 확장하는 것이 가능하다.
 *
 *핵심 참여자
 * - IVisitor는 방문자가 되고자 하는 클리스가 구현해야 할 인터페이스다.
 * - 방문자 클래스는 방문할 수 있는 각 요소에 방문자 메서드를 구현해야 한다.IVisitable은 방문이 
 *   가능한 클래스가 되기를 바라는 클래스가 구현해야 하는 인터페이스다. 방문자는 객체가 방문하는
 *   진입점을 제공하는 accept() 메서드가 포함된다.
 *
 * 장점 
 * - 개방/폐쇄 : 직점 수정하지 않고도 다른 클래스의 오브젝트와 함께 작동하는 새로운 동작을 추가 할 수 있다.
 *                   이 방식은 객체 지향 프로그래밍의 원칙인 엔티티가 확장하기 위해 열려 있어야 하지만 수정을 
 *                   위해서는 닫혀 있는 한다는 개방/폐쇄 원칙을 따른다.
 * - 단일 책임 : 방문자 패턴은 데이터를 보유하는 객체(방문 기능)를 가질 수 있고 또 다른 객체(방문자)는 
 *                   특정 행동을 도입하는 책임을 진다는 전에서 단일 책임 원칙을 준수할 수 있다.
 * 단점
 * - 접근성 : 방문자는 방문하는 요소의 특정 개인 필드 및 메서드에 필요한 접근이 적을 수 있다.
 *               클래스에서 패턴을 사용하지 않을 때보다 더 많은 공개 속성을 노출해야 할 수도 있다.
 * - 복잡성 : 방문자 패턴은 싱들턴, 상태, 오브젝트 풀 같은 간단한 패턴보다 구조적으로 훨씬 복잡하다.
 *               이는 코드베이스가 복잡해질 수 있어 다른 프로그래머가 패턴 구조와 복잡성에 익숙하지 않다면
 *               혼란을 겪을 수 있다.
 * 방문자는 이중 디스패티(double dispatch)라는 기본 설계에서 소프트웨어 엔지니어링 개념을 사용한다.
 * 소프트웨어 엔지니어링은 호출과 관련된 두 객체의 종류에 따라 런타임에 메서드 호출을 다른 구체적인 메서드로
 * 이관하는 메커니즘이다.
 * 
 */